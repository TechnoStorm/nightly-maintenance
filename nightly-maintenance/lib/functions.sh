#!/usr/bin/env bash
# functions.sh
# Скрипт определения функций

# Принудительно прерываем скрипт при ошибках, и неинициализированных переменных
set -euo pipefail


######################
# Определение функций
######################

# Функция логгирования
log() {
    local msg="[$(date '+%F %T')] $*"
    echo "$msg" >> "$LOG_FILE"
    echo "$msg"
}

echo "" >> "$LOG_FILE" # отступ
echo "========== $(date '+%F %T') ==========" >> "$LOG_FILE" # пустая строка, для разделения лога
echo "" >> "$LOG_FILE" # отступ

log "Запущен сценарий ночного техобслуживания NAS"


# Функция ошибки выполнения скрипта
fail() {
    log "[ERROR]: $*"
    log "Прерван сценарий ночного техобслуживания NAS"
    exit 1
}


# Функция обрезки лога (удаляются все строки, кроме последних $MAX_LOG_LINES)
trim_log() {
    if [[ -f "$LOG_FILE" ]]; then

        # Создаём временный файл лога, с уникальным именем
        local tmp_log
        tmp_log=$(mktemp "${LOG_FILE}.tmp.XXXXXX") || fail "Не удалось создать временный log-файл для обрезки лога"

        # Переназначаем владельца и права лог-файла
        chown "$LOG_CHOWN" "$tmp_log" || fail "Не удалось переназначить владельца и группу временного лог-файла"
        chmod "$LOG_CHMOD" "$tmp_log" || fail "Не удалось переназначить права доступа временного лог-файла"

        # Сохраняем последние $MAX_LOG_LINES строк во временный файл
        if tail -n "$MAX_LOG_LINES" "$LOG_FILE" > "$tmp_log"; then

            # Заменяем старый лог-файл на новый
            mv -f "$tmp_log" "$LOG_FILE" || fail "При обрезке лога не удалось заменить старый лог-файл обновлённым"
        else
            # Удаляем временный лог
            rm -f "$tmp_log"
            fail "Обрезка лога не удалась"
        fi
    fi
}
