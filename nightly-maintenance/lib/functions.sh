#!/usr/bin/env bash
# functions.sh
# Скрипт определения функций

# Принудительно прерываем скрипт при ошибках, и неинициализированных переменных
set -euo pipefail


######################
# Определение функций
######################

# Функция логгирования
log() {
    local msg="[$(date '+%F %T')] $*"
    echo "$msg" >> "$LOG_FILE"
    echo "$msg"
}


# Функция ошибки выполнения скрипта
fail() {
    log "ERROR: $*"
    log "Прерван сценарий ночного техобслуживания NAS"
    exit 1
}


# Функция обрезки лога (удаляются все строки, кроме последних $MAX_LOG_LINES)
trim_log() {
    if [[ -f "$LOG_FILE" ]]; then

        # Создаём временный файл лога, с уникальным именем
        local tmp_file
        tmp_file=$(mktemp "${LOG_FILE}.tmp.XXXXXX") || fail "Не удалось создать временный log-файл для обрезки лога"

        # Сохраняем последние $MAX_LOG_LINES строк
        if tail -n "$MAX_LOG_LINES" "$LOG_FILE" > "$tmp_file"; then

            # Заменяем старый лог-файл на новый
            mv -f "$tmp_file" "$LOG_FILE" || fail "При обрезке лога не удалось заменить старый лог-файл обновлённым"
        else
            rm -f "$tmp_file"
            log "ERROR: Обрезка лога не удалась"

            # Не прерываем скрипт через "fail()", так-как функция всё равно выполняется в самом конце
        fi
    fi
}
